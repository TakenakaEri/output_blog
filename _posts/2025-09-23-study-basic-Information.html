---
layout: post
title: "基本情報試験の学習"
subtitle: "プログラミング言語とは"
date: 2025-09-23
background: "/img/bg-about.jpg"
---

<p>今日はプログラミングの項目だったので、ある程度できるだろうと小テストに挑んだのですが、ケアレスミスをしてしまい、非常に悔しい思いをしました。</p>
<P>具体的にいうと、チェックディジットのプログラミングだったのですが、そもそもチェックディジットの役割を思い出せなかったので、学習した内容が身についていなくてショックでした。</p>
<p>セルフテストのように、学習した内容を思い出す時間を取り入れた方が良さそう。</p>

<h3>プログラミング言語とは</h3>
<h4>言語プロセッサ</h4>
<p>翻訳作業を行うプログラムの総称</p>
<p>
    <ul>
        <li>インタプリタ方式
            <p>1行ずつ機械語に翻訳しながら実行する。
                <br>書きながら試すことができる。
                <br>ただし、実行は遅い
                <br>例）BASICや初学者向けの言語
            </p>
        </li>
        <li>コンパイラ方式
            <p>最初に全て翻訳する
                <br>高速に実行できる
                <br>例）COBOL、Java、C言語
            </p>
        </li>
    </ul>
</p>
<h4>コンパイラの仕事</h4>
<p>ソースコードを機械語に翻訳する
    <ul>
        <li>字句解析（ソースコードを字句（トークン）単位に分解する）</li>
        <li>構文解析（分解したトークンを構文規則に従って解析する）</li>
        <li>意味解析（変数の型や文がプログラム言語の使用に従っているかチェックする）</li>
        <li>最適化（処理効率の向上を目的として、再編成を検討する）</li>
        <li>コード生成（目的プログラム（オブジェクトプログラム）を生成する）</li>
    </ul>
</p>
<h4>リンカの仕事</h4>
<p>自分で分割したモジュールやライブラリなどを全て繋ぎ合わせることで実行が可能になる。
    <br>実行可能ファイル（ロードモジュール）が生成される
    <ul>
        <li>リンク（連係編集）</li>
        <li>リンカ（連係編集プログラム）</li>
        <li>静的リンキング
            <p>あらかじめリンクさせておく手法のこと</p>
        </li>
        <li>動的リンキング
            <p>プログラムの実行時に、共有ライブラリやシステムライブラリをロードしてリンクする手法</p>
        </li>
    </ul>
</p>
<h4>ローダの仕事</h4>
<p>ロードモジュールを主記憶装置に読み込ませる作業のことを<strong>ロード</strong>という。これを担当するプログラムが<strong>ローダ</strong>。
</p>
<h4>構造化プログラミング</h4>
<p>
    <ul>
        <li>順次構造</li>
        <li>選択構造（条件分岐）</li>
        <li>繰り返し構造</li>
    </ul>
</p>
<h4>リスト（線形リスト）</h4>
<p>データとデータを数珠繋ぎにして管理するのが線形リスト</p>
<p><strong>ポインタ</strong>と呼ばれる番号がセットになってくっついていて、メモリ上の位置を表す番号（次のデータがどこになるかを示している）</p>
<p>ポインタを書き換えればいくらでもデータを繋ぎ変えることができるので、データの追加・挿入・削除が簡単に行える。</p>
<p>※ リストはポインタを順に辿らなければいけないため、配列みたいに「添え字を使ってここのデータに直接アクセスする」ということはできない</p>
<ul>
    <li>単方向リスト
        <p>次のデータへのポインタを持つリスト。</p>
        <p>一方通行なので、先頭から順に辿っていくしかない</p>
    </li>
    <li>双方向リスト
        <p>次のデータへのポインタと、前のデータへのポインタを持つリスト</p>
        <p>前後のどちらにもリストを巡っていくことができる</p>
    </li>
    <li>循環リスト
        <p>次のデータへのポインタを持つリスト。最後尾のデータは先頭のデータへのポインタを持つ</p>
        <p>全体が循環につながっている</p>
    </li>
</ul>
<h4>キュー</h4>
<p>待ち行列といわれ、最初に格納したデータから順に処理を行う。先入先出し方式（FIFO：First In First Out）</p>
<p>入力されたデータが順番通りに処理されなければ困る状況で使われる。
    <ul>
        <li>エンキュー（enqueue）
            <p>キーに入れる操作</p>
        </li>
        <li>デキュー（dequeue）
            <p>キューから取り出す操作</p>
        </li>
    </ul>
</p>
<h4>スタック</h4>
<p>後入れ先出し（LIFO：Last In First Out）</p>
<p>サブルーチンの呼び出し後に呼び出し元に戻れるのが、「サブルーチン実行後どこに戻るのか」がスタックとして管理されているから
    <ul>
        <li>入れること：PUSH</li>
        <li>取り出すこと：POP</li>
    </ul>
</p>
<h4>データ探索アルゴリズム</h4>
<p>
    <ul>
        <li>線形探索方
            <p>先頭から順に探索していく方法</p>
            <p><strong>番兵</strong>：最終判断を簡単にするため末尾に付加したデータのこと</p>
            <p>添字の末尾がnの場合は、n+1に目的のデータを入れて「配列の中に目的のデータが必ず存在する」状況を作る。</p>
            <p>これをることで「目的のデータか？」の判断と「添字を超えたか？」の判断の2つの条件から、「添字範囲を超えたか？」の条件を省略することができる。</p>
        </li>
        <li>2分探索方
            <p>対象のデータ群が「昇順に並んでいる」「降順に並んでいる」といった規則性を持つ場合に使える。</p>
            <p>真ん中のデータと探索対象のデータを比較する（二分の一ずつ削り落としていける）</p>
            <p>loとhiの値を移動させながらループする</p>
        </li>
        <li>ハッシュ法
            <p>ハッシュ関数と呼ばれる「一定の計算式」を用いて、データの格納位置を算出する。</p>
            <p><strong>シノニム</strong>：同じハッシュ値を持つデータ群(ハッシュ関数の計算結果が衝突する)</p>
        </li>
    </ul>
</p>
<h4>各アルゴリズムにおける探索回数</h4>
<p>
    <ul>
        <li>線形探索法
            <p>平均探索回数：(1＋n)÷2
                <br>最小回数と最大回数を2で割る
            </p>
        </li>
        <li>2分探索法
            <p>均探索回数：log2n
                <br>データが2倍になって初めて探索回数が1増える
            </p>
        </li>
        <li>ハッシュ法
            <p>均探索回数：1回</p>
        </li>
    </ul>
</p>
<h4>データを整列させるアルゴリズム</h4>
<p>
    <ul>
        <li>基本交換法：バブルソート
            <p>隣接するデータの代償を比較し、必要に応じて入れ替えることで全体を整列させる</p> 
       </li>
        <li>基本選択法：選択ソート
            <p>対象となるデータから最小値（もしくは最大値）を取り出して、先頭のデータと交換。これを繰り返して全体を整列させる。
                <br>一度交換した先頭のデータは確定する。
            </p>
        </li>
        <li>基本挿入法：挿入ソート
            <p>「整列済み」のものと「未整列のもの」を分けて、未整列のデータを1つ取り出して、整列済みの中のどの位置が最適化を決定して挿入する。
                <br>（最初は全てが未整列）
            </p>
        </li>
        <li>より高速な整列アルゴリズム
            <p>
                <ul>
                    <li>シェルソート
                        <p>ある一定おきに取り出した要素で部分列を作り、それぞれを整列して戻す。今んどはサレ兄感覚を詰めてと嘘を取り出し、再度整列。感覚が1になるまでこれを繰り返す。
                            <br>例）間隔4→間隔2→間隔1
                        </p>
                    </li>
                    <li>クイックソート
                        <p>中間の基準値を決めて、基準値よりも「小さい値」と「大きい値」に分ける。その後、それぞれのグループ内で基準値を決めて振り分けることを繰り返す。</p>
                    </li>
                    <li>ヒープソート
                        <p>未整列の部分を「順序木」と呼ばれる木構造に構成して、そこから最大値（もしくは最小値）を取り出して、整列済みの側へ移す。
                            <br>（根の部分を取り出して、整列済みに移す）
                        </p>
                    </li>
                </ul>
            </p>
        </li>
    </ul>
</p>
<h4>オーダー記法</h4>
<p>アルゴリズムの計算量（実行時間）をO(式)の形で表すもの。（大まかな処理効率を図るもの）</p>
<p><strong>オーダー</strong>：そのアルゴリズムに要する実行時間はどのように変化するか。</p>
<p>※ 「アルゴリズムにおけるデータ量と計算量との関係」オーダーが同じであっても、処理時間が同じという意味にはならない。</p>
<p>
    <ul>
        <li>探索アルゴリズムのオーダー
            <ul>
                <li>線形探索法法：O(n)
                    <p>ひとつずつ見ていくので、nが増えた分、処理（探索）の回数も増える</p>
                </li>
                <li>2分探索法：O(log2n)
                    <p>二分の一ずつ絞り込む方式なので、処理の回数が増えるのはデータが2倍になった時</p>
                </li>
                <li>ハッシュ法：0(1)
                    <p>ハッシュ関数を使って直接アクセスするので、件数nに左右されない</p>
                </li>
            </ul>
        </li>
        <li>整列アルゴリズムのオーダー
            <ul>
                <li>基本交換法（バブルソート）：O（n2）</li>
                <li>基本選択法（選択ソート）：O（n2）</li>
                <li>基本挿入法（挿入ソート）：O（n2）</li>
                <li>シェルソート：O（n1.2）</li>
                <li>クイックソート：O(nlog2n)</li>
                <li>ヒープソート：O(nlog2n)</li>
            </ul>
        </li>
    </ul>
</p>
<p>※ オーダー記法においては、定数の係数は無視できる。例えば、log2nはlognのように書ける。</p>
<h4>類似言語問題を読み解く</h4>
<ol>
    <li>コードは「何について書かれているか」を予測できるようにすることで読みやすさが変わる</li>
    <li>何をするためのコードかを考えて処理の流れを予測する</li>
    <li>予測と照らし合わせながらソースコードをブロック単位にわける</li>
    <li>各ブロックに注目して、コードを詳細に読み解く</li>
</ol>

<h3>未来の私へ</h3>
<p>今月は後残り7日です。試験間に合いますか？本来の学習計画だと、明日学習が終わって過去問を実施するフェーズに入る予定です。
    <br>もう一度気合いを入れ直しましょう！！ファイト！！
</p>

